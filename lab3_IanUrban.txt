//Got assistance from Mr.Buckstein
//Also referced code from: https://raytracing.github.io/books/RayTracingInOneWeekend.html#addingasphere/ray-sphereintersection
//Aswell as: https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.pdf


// calcViewport: calculate the viewing plane (viewport) coordinate
//    viewport:       output viewing plane coordinate
//    ndc:            output normalized device coordinate
//    uv:             output screen-space coordinate
//    aspect:         output aspect ratio of screen
//    resolutionInv:  output reciprocal of resolution
//    viewportHeight: input height of viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv,
                  out float aspect, out vec2 resolutionInv,
                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)
    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));
}


// calcRay: calculate the ray direction and origin for the current pixel
//    rayDirection: output direction of ray from origin
//    rayOrigin:    output origin point of ray
//    viewport:     input viewing plane coordinate (use above function to calculate)
//    focalLength:  input distance to viewing plane
void calcRay(out vec4 rayDirection, out vec4 rayOrigin,
             in vec2 viewport, in float focalLength)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = vec4(0.0, 0.0, 0.0, 1.0);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = vec4(viewport.x, viewport.y, -focalLength, 0.0);
}

vec4 rayMath(float t)
{
   vec4 dir;
   vec4 orig;
    
   return orig + t*dir;   
}


float genCircle(vec3 point3, float radius)
{
  vec4 rayOrigin;
  vec4 rayDirection;
    
  vec4 center;
  vec4 cirle;
  
    
  vec4 oc = rayOrigin - center;
    
  float a = dot(rayDirection, rayDirection);
    
  float b = 2.0 * dot(oc, rayDirection);
      
  float c = dot(oc, oc) - radius*radius;
    
  float discrim = (b*b) - (4.0*a*c);
    
  if(discrim < 0.0)
  {
   	return -1.0;
      
  } else 
   {
      return (-b - (discrim* discrim) ) / (2.0*a);
   }
   
}


// calcColor: calculate the color of a pixel given a ray
//    rayDirection: input ray direction
//    rayOrigin:    input ray origin
vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{  
   vec4 Num;
   float result;
   vec4 returner;
   vec4 otherReturn;
    
    
   float t = genCircle(vec3(0.0, 0.0, -1.0), 0.5);
   
   if(t > 0.0)
   {
       Num = rayMath(t) - vec4(0.0, 0.0, -1.0, 1.0); 
       
       result = 0.5 *(Num.x+1.0, Num.y+1.0, Num.z+1.0);
       returner = vec4(vec3(result), 1.0);
       
       return returner;
   }
    
    
    t = 0.5*(rayDirection.y + 1.0);
    
    sign(t);
    
    otherReturn = vec4(vec3(t), 1.0);
   	
    return otherReturn;
}




// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    
    // viewing plane (viewport) info
    vec2 viewport, ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
                 viewportHeight, fragCoord, iResolution.xy);
    calcRay(rayDirection, rayOrigin,
            viewport, focalLength);
    

    //background color
    fragColor = calcColor(rayDirection, rayOrigin);

    // TEST COLOR:
    //  -> what do the other things calculated above look like?
    //fragColor = vec4(viewport, 0.0, 0.0);
    //fragColor = vec4(ndc, 0.0, 0.0);
    //fragColor = vec4(uv, 0.0, 0.0);
    
    
    
    
    
    
    
    
    
    
    
    //float a = 1.0 + 2.0; //single  parrallel op
    
    //be careful using conditionals, if-else, switch
    //make them efficent to avoid rollback
    //aka anytime something needs to be compared to something else
    //one way is to have simple if-else statements
    //if you can do the math yourself, this is better than using a conditional
    //use if statements if you need to use logic within your conditional
    //gpu not very good at conditionals or boolean logic
    
    
    //a turarary operator is one way to avoid conditional
    //also this is the sin function
    //float b = a < 0.0 ? -1.0: +1.0;
    //abs form of this is
    //float b = a < 0.0 > -a: +a;
    
    //if(a > 0)
    //{
        
    //} else
    //{
        
    //}
    
    //vec4 result = vec4(0.0);
    //int numSamples = 8;
    //int i = numSamples;
    //++i is faster since it doesn't copy the i var like i++
    //comments go from slowest to fastest in this section
    //for(i = 0; i < numSamples; i++)
    //for(i = 0; i < numSamples; ++i;)
    //for(i = numSamples - 1; i < 0; --i)
   // {
   //  	   result += vec4(float(i));
  //  }
    
    //looks wierd, but cut out forloop
    //does this 8 times just like forloop
    //is actually faster than forloop
    //also gpu will most likly read the forloop
    //like this anyway, but doing something known as unrolling
    //result+=addColor(--i);
    //result+=addColor(--i);
    //result+=addColor(--i);
    //result+=addColor(--i);
    //result+=addColor(--i);
    //result+=addColor(--i);
    //result+=addColor(--i);
    //result+=addColor(--i);
    
    
    //examples of faster multiplcation
    //if you know the power function don't use pow
    //if you don't know power funtion then use pow
    //float aSq = a*a; //pow(a,2.0), don't do this not efficent if you dont need
    //to use it
    //float aCubed = a* aSq;
    //float a4 = aSq * aSq;
    //fast way to square a;
    //only use when you don't need orginal a
    //a*=a;
 	//a*=a; //give you a ^ 4
    //a*=a; //gives you a ^ 8
    
    //better way is to make a function for what you need 
    //then pass it 
    //a = pow64(a);
    
    //square length of raydirection
    //never do this float lengSq = length(raydirection) * length(raydirection)
    //problem with thing above, 1: not algebraic
    //problem 2: given yourself 4 more operations that you don't need to do 
    //float lengSq = raydirection.x * raydirection.x +
        		  //raydirection.y * raydirection.y
        
    //more efficent than writting out    
    //float lengSq = dot(raydirection.x, rayDirection.y)
        
    //or do this
    //writing a function is usally just as fast as writting code in main
    //very useful orginzational technique 
    //float lengSq = lengthSqr2(rayDirection);
    
    
    //vec2 s = rayDirection.xy;
    
    
    
}
//dummy functions
/*vec4 addColor(int index, in vec4 data)
{
    //do something important
 	return vec4(float(data));   
}


float pow64(float x)
{
 	x*=x; //^2
    x*=x; //^4
    x*=x; //^8
    x*=x; //^16
    x*=x; //^32
    x*=x; //^64
    
    return x;
}

//getting sqr length of vec2-4 using dot
float lengthSqr2(in vec2 x)
{
 	return dot(x,x);   
}

float lengthSqr3(in vec3 x)
{
 	return dot(x,x);   
}

float lengthSqr4(in vec4 x)
{
 	return dot(x,x);   
}*/
