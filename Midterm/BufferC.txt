//sources used: 
//https://ebookcentral-proquest-com.cobalt.champlain.edu/lib/champlain/reader.action?docID=948515

//sources used: 
//https://ebookcentral-proquest-com.cobalt.champlain.edu/lib/champlain/reader.action?docID=948515

//A function used to calculate the diffuse coefficient for the lamber
float calcDiffCoefficient(in sPointLight pointLight, in sSurface surface)
{
    //Lambert's Cosine Law 			
    vec3 rSurface = surface.surfacePoint;			
    vec3 surfaceNorm = surface.surfaceNormal.xyz;
    
    vec4 lightRay = vec4(normalize(pointLight.center.xyz - rSurface.xyz), 1.0); //optimize
   
    //float diffCoefficient = cos(uniSurfaceNorm * lightPos);
    float diffCoefficient = max(0.0, dot(surfaceNorm, lightRay.xyz)); //this might be wrong
    
    return diffCoefficient;
}

//find the x Coord
float findCoordX(in sPointLight pointLight, in sSurface surface,float xCoord)
{
    //creating local vars
    //pointCenter and surfacePoint
    //To be used in finding the xCoord
    vec3 pointCenter = pointLight.center.xyz;
    vec3 surfacePoint = surface.surfacePoint.xyz;
    
    //set the xCood equal to the pointCenter.x minus
    //the surfacePoint.x
    xCoord = pointCenter.x - surfacePoint.x;
    
    //returning the XCoord
    return xCoord;
}

//find the y Coord
float findCoordY(in sPointLight pointLight, in sSurface surface, float yCoord)
{
    //creating local vars
    //pointCenter and surfacePoint
    //To be used in finding the yCoord
    vec3 pointCenter = pointLight.center.xyz;
    vec3 surfacePoint = surface.surfacePoint.xyz;
    
    //set the ycood equal to the pointCenter.y minus
    //the surfacePoint.y
    yCoord = pointCenter.y - surfacePoint.y;
    
    //returning the yCoord
    return yCoord;
}

//find the z Coord
float findCoordZ(in sPointLight pointLight, in sSurface surface, float zCoord)
{
    //creating local vars
    //pointCenter and surfacePoint
    //To be used in finding the zCoord
    vec3 pointCenter = pointLight.center.xyz;
    vec3 surfacePoint = surface.surfacePoint.xyz;
    
    //set the ycood equal to the pointCenter.z minus
    //the surfacePoint.z
    zCoord = pointCenter.z - surfacePoint.z;
    
    //returning the zCoord
    return zCoord;
}

//find the square of the x Coord
float calcXSqr(float squareX)
{
    float x;
    
    squareX = x*x;
    
    return squareX;
}

//find the square of the y Coord
float calcYSqr(float squareY)
{
    float y;
    
    squareY = y*y;
    
    return squareY;
}

//find the square of the z Coord
float calcZSqr(float squareZ)
{
    float z;
    
    squareZ = z*z;
    
    return squareZ;
}


//find the square of the intensity
float findSqrInten(in sPointLight pointLight, float inten)
{
	float sqrInten;
    
    //setting the intensity 
    //so it can be squared below
   	inten = pointLight.intensity;
    
    sqrInten = inten * inten;
    
    return sqrInten;
}

//find the light intensity
float findDivLightInten(in sPointLight pointLight, float inten)
{
   //grabbing all the squares of the xyz coords
   float xCoord; 
   float squareX = calcXSqr(xCoord);
    
   float yCoord;
   float squareY = calcYSqr(yCoord);
    
   float zCoord;
   float squareZ = calcZSqr(zCoord);
    
    
   //calculating light ray distance
   float lightRayDist = sqrt(squareX + squareY + squareZ); 
    
   //setting intenisty so it can be used in
   //the calculation of divLightInten
   inten = pointLight.intensity; 
   
   //calculating the divLightInten using
   //the calculated lightRayDit and inten
   float divLightInten = lightRayDist/inten; 
    
   //returning the calculated divLightInten 
   return divLightInten;
}

//find the square of the light distance
float findSqLightDis()
{
   //grabbing all the squares of the xyz coords
   float xCoord; 
   float squareX = calcXSqr(xCoord);
   
   float yCoord;
   float squareY = calcYSqr(yCoord);
   float zCoord;
   float squareZ = calcZSqr(zCoord);
    
    
   //calculating light ray distance
   float lightRayDist = sqrt(squareX + squareY + squareZ); 
    
   //calculating the sqr of lightRayDist 
   float lightRayDistSqr = lightRayDist * lightRayDist;
    
   //returning that calculated value
   return lightRayDistSqr;
}

//calculate the attenuation
float calcAttenuation(in sPointLight pointLight, in sSurface surface)
{
    //local var for returning
    //the end data
    float attenuInten;
    
    //operations
    float sqLightDist = findSqLightDis();
    
    //creating local inten so its square value
    //can be found using the sqInten function
    float inten;
    //calculating the sqInten
    float sqInten = findSqrInten(pointLight,inten);
    
    //grabbing the calculated divLightInten using the
    //findDivLightInten function
    float divLightInten = findDivLightInten(pointLight, inten);
    
    //calculating the attenuation
    attenuInten = 1.0/(1.0 + divLightInten) 
                            + (sqLightDist/sqInten);
    
    //returning the calculated attenuation
    return attenuInten;
}

//a function used to find the diffuse intensity
float calcDiffInten(out sSurface surface, in sPointLight pointLight)
{
    //grabbing the diffuse coefficient via the 
    //calcDiffCoefficient function
    float findDiffCoef = calcDiffCoefficient(pointLight, surface);
    
    //grabbing the attenuation via the 
    //calcAttenuation function
    float findAttenu = calcAttenuation(pointLight, surface);
    
    //calculating the diffuse intensity 
	//using the calculated diffuse coefficent and attenunation
    float diffInten = findDiffCoef * findAttenu; 
    
    //returning the calculated diffuse intensity 
    return diffInten;
}

//a function that calculates the final lambertain color
vec4 calcLambertainCol(out sSurface surface, in sPointLight pointLight, in vec4 rayOrigin)
{   
    //var normal for setting the normal
    vec3 normal;
  
    //setting the normal
    surface.surfaceNormal = normal;
   
    //cast the normal to a vec4 so it can be used
    vec4 normalCol = vec4(normal * 0.5 + 0.5, 1.0);
    
    //cast the calculated diffuse intensity to a vec4 so it can be used
   	vec4 diffIntesityVec4 = vec4(vec3(calcDiffInten(surface, pointLight)), 1.0);
    
    //calculate the final lambertain color
    vec4 lambertianColor = diffIntesityVec4 * normalCol;
    
    //returning 
    return lambertianColor;
}

//render the lamber
render4 renderLamber(out sSurface surface,in sPointLight pointLight, in vec4 rayOrigin)
{   
    //grabbing the final calculated lamber color
    //using the calcLambertainCol function
   	vec4 lamberReturner = calcLambertainCol(surface, pointLight, rayOrigin); 
    
    //returning the lamberReturner to render it
    return lamberReturner;   
}
     

//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
   	sSurface surface;
    sPointLight pointLight;
    vec4 rayOrigin;
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
   	//pass the first blur
    fragColor += renderLamber(surface, pointLight,rayOrigin);
}